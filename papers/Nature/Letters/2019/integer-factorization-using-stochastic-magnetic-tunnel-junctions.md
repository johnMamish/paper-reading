## Integer Factorization Using Stochastic MTJs
#### [[authors/Hideo Ohno]], et al, 2019

Classical computers struggle with NP-hard problems, a class of problems whose solutions require a number of operations proportional to an exponent of the input size. For small inputs, these problems are tractable, but quickly become impossible as the input size increases. NP-hard problems are ubiquitous across many fields; furthermore, all NP-hard problems are computationally equivalent: one NP-hard problem can be re-posed as a different NP-hard problem.

Quantum computing has emerged as an entirely different way of approaching NP-hard problems. Quantum computers can solve NP-hard problems in polynomial time by using entirely different, statistical methods. Unfortunately, quantum computers face a number of implementation challenges. Stoquastic (not stochastic) computing is a computing paradigm inspired by quantum computation, where a circuit outputs random states which are biased by the system design to be in a “solution state” more often than not. Therefore, by constructing a histogram of visited system states, the solution to a problem can be determined. Stoquastic computing is not without its downsides - many, many samples must be taken before a solution is converged upon, requiring many stoquastic circuits to operate in parallel.

The authors of this paper introduce an MTJ-based version of a fundamental stochastic computing  building block - the probabilistic bit (P-Bit) - which is much smaller and lower-power than comparable CMOS alternatives. To demonstrate that their P-Bit is usable in stochastic computations, they successfully factor 3 semi-prime numbers using a Boltzmann machine which generates randomness using their MTJ-based P-Bits. They also characterize the stochastic switching behavior of their P-Bits.

The P-Bits in this paper work by thermally switching between Parallel (P) and Anti-Parallel (AP) states. While MTJs engineered for data storage have a large energy barrier between their P and AP states to prevent spurious switching, the MTJs produced for this paper have a very low energy barrier. While this makes them unsuitable for data storage (because they’re constantly flipping from P to AP), it makes them excellent random number generators. P-Bits must generate a random sequence of bits whose distribution is biased by an input voltage; the MTJ is set up such that it switches between its P and AP states with a probability dependent on the current flowing through it. An analog comparator is used to transduce the MTJ’s state into a bit. The MTJ’s stochastic switching will result in a corresponding stochastic bitstream. As can be seen from figure 2b, the probability distribution of the output of their P-Bit can be modulated by an input voltage, which controls the current over the MTJ.

The authors fabricate many MTJs with different diameters and free-layer thicknesses to find MTJs that are sufficiently unstable. Their results can be seen in Figure 1c.

In order to show that these building-blocks can perform useful computation, the authors use 8 P-Bits to generate randomness for a Boltzmann machine which factors semiprime numbers. The P-Bits are driven with analog voltages by a microcontroller in order to generate random bits; the voltages used to drive the P-Bits represent probabilities of a solution state to the factorization problem. The microcontroller reads the random bits generated by the P-Bits, evaluates the “correctness” of the solution via a cost function, and then chooses a new state based on the gradient of the cost of the previous configuration. If this scheme is followed, different network states will be visited with probabilities corresponding to how “correct” they are. It’s worth noting that the gradient calculations and state update calculations are not done by the MTJs. These are done by a classical CPU; the MTJs are just used as a source of randomness to evaluate the fitness of a solution. Because the network “will visit different configurations with probabilities … proportional to [the exponent of their cost]”, the authors merely need to make a histogram of visited states to find the solution to their prime factorization problem.
  
The authors in this paper construct a P-Bit using an MTJ. They experimentally characterize its randomness and show that its randomness is sufficient for evaluating a Boltzmann machine.

Some thoughts / criticisms about this work

1.  They claim that their system is a 10x improvement in energy per random bit and a 200x improvement in transistor count over CMOS P-Bits. I find this highly suspicious. It appears that they haven’t taken the DAC into account when making this determination, which will be very difficult for scaling. An argument could easily be made that the cost of the ADC could be amortized over many P-Bits, however, I don’t see that anywhere in their discussion.
2.  Moreover, they don’t cite a work for the 32-bit LFSR they implement for comparison. How should we know this is state of the art? I believe there are certainly much better CMOS options.
3.  I would’ve liked to see more different numbers factored.
4.  There are interesting engineering challenges in extending this to a larger system.

keywords: [[keywords/spintronics]], [[approximate-computing]]